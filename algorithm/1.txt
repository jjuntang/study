1번째 칸부터 N번째 칸까지 
1부터 N까지 숫자가 순서대로 하나씩 들어 있

➀ 왼쪽으로 밀기 
➁ 구간 뒤집기 
➂ 왼쪽으로 밀기 

 K-왼쪽밀기라고 부른다. 
 (P,Q)-구간뒤집기 항상 P<Q
 다시 5-왼쪽밀기
 
 3-왼쪽밀기, (7,9)-구간뒤집기, 다시 5-왼쪽밀기의 
 
 
 잠긴 자물쇠의 마지막 상태를 입력으로 받아서
 그렇게 만든 3회의 동작을 찾아내는 프로그램을 작성하시
 
 자물쇠 모양이 그림 4와 같다면 
 그 답은 3-왼쪽밀기, 
 (7,9)-구간뒤집기, 
 5-왼쪽밀기이다.
 
 
 처음 K-왼쪽밀기의 를 첫째 줄에,
 (P,Q)-구간뒤집기의 P와 Q를 빈칸을 사이에 두고 둘째 줄에
 마지막 K-왼쪽밀기의 K를 셋째 줄
 
 1 2 3 4 5 6 7 8 9 10
 4 5 6 7 8 9 10 1 2 3
 4 5 6 7 8 9 2  1 10 3
 9 2 1 10 3 4 5 6 7 8
 
 5 6 7 8 9 2 1 10 3 4
 
 1. 가장 큰수 : 1 
 2. 가장 작은 수 : 10 
 3. 뒤집힌 부분의 구간을 찾는다. : 2 ~ 3 
 4. 3 번에서 크기만큼 루프
 for(i=1; i<10; i++)
 {
	1. i 번 K-왼쪽밀기
	2. 역 구간 뒤집기
	for(j=0; j<10; j++)
	{
		3. j 번 K-왼쪽밀기
		4. 만약 순서대로 되었다면 출력 
	}
 }
 
 
 -------------------------------------------
 
 
 현재 상황에서 가장 좋은 것(최선의 선택)을 고르는
 
 동적 프로그래밍을 간단한 문제 해결에 사용하면 지나치게 많은 일을 한다는 것을 착안하여 
 
 그리디 알고리즘은 현재 상황에서 가장 좋은 결과를 선택해나가는 방식입니다
 하지만 이 가장 좋은 결과는 최종적인 결과 도출에 대한 최적해를 보장해주는 것은 아닙니다!
 
 여기서 가장 좋은 것(최선의 선택)
 
 
 현재 상황에서 가장 좋은 결과를 선택하는 방식입니다!
 
 이 선택으로 인해 전체 문제의 최적해를 반드시 도출할 수 있어야 한다는 것입니
 
 알고리즘을 사용해 푸는 문제가 나왔을 때 이 조건이 만족되는가? 를 생각해 충족되면 그리디 알고리즘을 사용하는 것입니다.
 
 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적의 해결 방법이다라는 조건입니다.
 
 이 말은 전체 문제의 안에는 여러 단계가 존재하고, 
 이 여러 단계 내의 하나 하나의 단계에 대해 최적해가 도출되어야 한다는 것입니다.
 
 
  값들이 서로 영향을 주면 안된다는 것을 염두에 두어야 합니다